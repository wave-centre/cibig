---
title: 'IRD/CIRAD trainning to R, the statistical programming language'
author: "Sebastien Cunnac & Emmanuel Paradis"
date: "Sept. 7-11, 2015"
output:
  ioslides_presentation:
    smaller: yes
    widescreen: no
---

```{r setup, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(error = TRUE, collapse = TRUE)
```



# Loops and conditional execution.

## Conditional constructs {.build}

General syntax:

```{r, eval = FALSE}
if (condition) true_expression

if (condition) true_expression else false_expression

if (condition) {
    true_expression
} else {
    false_expression
}

if (condition) true_expression else if (condition) true_expression else false_expression
```

* Here again braces can be ommited if code block is composed of a single statement.
* For readability I would not be greedy about them when it gets complicated because they are visible "fence posts".


##

* A few examples

```{r}
if (FALSE) "this will not be printed" else "this will be printed"

x <- 3
if (is(x, "numeric")) x/2 else print("x is not numeric")

# The condition statement should be logical and of length one
if (1:3 < 2:4) "It works but will be discussed later"

# For compact assignement
y <- if(x == 2) x else x + 1
```



* Nested statements

```{r}
if (y < 0) {
   print("Negative number")
} else if (y > 0) {
   print("Positive number")
} else
   print("Zero")
```




## Vectorized conditional constructs {.build}

Syntax: `ifelse(test, yes, no)`

* `test` must be a logical vector (or an object that can be coerced to logical).  
* The return value is a vector with the same length as `test`.
* This returned vector has element `i` from: 
    - `yes[i]` if the corresponding value of `test` is TRUE
    - `no[i]` if the corresponding value of `test` is FALSE.
* **BEWARE**, the vectors `yes` and `no` are recycled whenever necessary.

```{r}
a = c(5,7,2,9)
ifelse(a %% 2 == 0,"even","odd") # yes annd no are recycled
```

##

```{r}
x <- c(4:-3)
sqrt(x)  #- gives warnings!
recodedX <- ifelse(x >= 0, x, NA)
sqrt(recodedX)  # no warning
```

Often used for elementwise change to a vector but most of the time it is better to build constructs based on logical indexing and assignement operators.
The previous `ifelse()` call can be written as such:
```{r}
x[x < 0] <- NA
sqrt(x)
```

## *Conventional* iteration constructs {.build}

* A `for` loop repeats a chunk of code for each element in a set of input.

Syntax: `for(var in seq) expr`

```{r}
s <- c("My", "first", "for", "loop")
for (value in s) {
  print(value)
}
```

Can you rewrite this using integer indexing: `for (i in 1:length(vecLet)) {`â€¦
```{r}
i <- 3
s <- c("My", "first", "for", "loop")
for (i in seq_along(s)) print(s[i])
```
Is the value different? What happens if you remove the call to `print()`?


##

* `for` loops can be nested: the multiplication table example ([Source: The DataCamp Blog](http://blog.datacamp.com/tutorial-on-loops-in-r/)).

```{r}
mymat = matrix(nrow = 10, ncol = 10) # create a 10 x 10 matrix (of 10 rows and 10 columns)

for(i in 1:dim(mymat)[1]) {      # for each row
  for(j in 1:dim(mymat)[2]) {    # for each column
    mymat[i,j] = i*j             # assign values based on position: product of two indexes
  }
}
head(mymat)

```

BTY, using specialized R function, this can be coded in one line:
```{r}
mymat2 <- outer(1:10, 1:10, FUN = `*`)
identical(mymat, mymat2)

```





## *Conventional* iteration constructs {.build}

* Syntax: `while(cond) expr`

```{r}
i <- 6
while (i < 10) { i = i + 1; print(i) ; }
```

* Syntax: `repeat expr`

```{r}
repeat {
  print(i) ; i = i + 1
  if (i >= 13) break
}
```

* Note that repeat has no Boolean exit condition. It will brutally iterate forever unless you use the control statemtent `break` (or something like `return()`). Of course, `break` can be used with `for` and `while` loops, too.  
BTW how do you force your code to stop running in RStudio? In the console?

##

* `next` tells the interpreter to skip the remainder of the current iteration of the loop and proceed directly
to the next one:

```{r}
i <- 6
while (i < 10) {
  i = i + 1
  if (identical(i, 8)) next
  print(i)
}
  
```

## A subtle note on deciding about equality of objects {.build}

A call to `identical()` is the recommended way to test exact equality in `if` and `while` statements as well as with `&&` and `||` operators because it returns a scalar value and there is more stricter control on type comparison.


```{r}
if(1 != NULL) cat("Too Bad!")
if(!identical(1, NULL)) cat("Too Bad!")

1 == as.integer(1)
identical(1, as.integer(1)) # stored as different types
1L == as.integer(1) 
typeof(1)
typeof(1L)
```




## Exercice: {.build}
Can you think of a better way to write:  
`for (i in 1:length(b)) {a[i] <- cos(b[i])}`  
using a simple assignment?

```{r ANS01}
b <- seq(1, by = pi, length.out = 4) # create b
b

a <- numeric(0)
for (i in 1:length(b)) { a[i] = cos(b[i]) }
a

a <- cos(b) # this is the trick!
a
```
Whenever you have the need for a looping construct, first ask yourself whether there is not an easy/elegant and more computing efficient way to write it using **R's distinctive vectorization paradigm**.

## Exercice: {.build}

Along the same line, take the following code:

```{r}
set.seed(123)
for (i in 1:10) {
  x <- runif(1, max = 10)
  if (x > 5) y[i] <- factorial(as.integer(x))
  else y[i] <- x }
y
```
Can you rewrite it using the `ifelse()` function?

```{r ANS02}
set.seed(123)
x <- runif(10, max = 10) # generating all necessary x values
z <- ifelse(x>5, factorial(as.integer(x)), x) # substitute 'if' in the loop for ifelse()
identical(y, z) # check that this is indeed the same
```


## Exercice: {.build}
[Source: R for Biologists - Prof. Daniel Wegmann](https://moodle2.unifr.ch/course/view.php?id=9409)


Write a function `do.it()` that takes two arguments `p` and `q` (scalar numeric vectors) and returns `q/p` if `p > 0` and returns `p/q` otherwise.

```{r ANS04}
do.it <- function(p, q){
  if(p > 0){
    return(q/p);
  } else {
    return(p/q);
  }
}
```

Apply it to the elements of x and y of the matrix defined below using a loop that populate a vector of results with each iteration.
```{r}
d <- cbind(x = round(runif(n = 4, min = -5, max = 5)),
            y = round(runif(n = 4, min = -2, max = 2)))
t(d) # print the transposed matrix because of space constraints
```

##

```{r ANS05}
r <- numeric(0)
for(i in 1:nrow(d)){
  r[i] <- do.it(d[i, "x"], d[i, "y"])
}
r
```




## The `apply` family of functions {.build}
* `for` loops can be:
    - complicated to code and understand especially when they operate on complex objects or do elaborate processing (see the nested loop example).
    - supposedly slow to run in R due to intrinsic language mecanisms. 

* The very rich, powerful, but also confusing family of `apply` functions:
    - manipulate and compute on slices of data from typical R data structures (vector, matrices, lists, data frames)
    - easier to read and code after a bit of practice.
    - made of intrinsically vectorized functions which are faster at iterating.
    - but computation in each iteration has to be independant of previous iterations.

## The `apply` family of functions {.build}
<div class="columns-2">

Function      |   Usage
--------------|---------
base::lapply  | Apply a Function over a List or Vector
base::apply   | Apply Functions Over Array Margins
base::mapply  | Apply a Function to Multiple List or Vector Arguments
base::by      | Apply a Function to a Data Frame Split by Factors
base::tapply  | Apply a Function Over groups of values (Ragged Array)
base::eapply  | Apply a Function Over Values in an Environment
base::rapply  | Recursively Apply a Function to a List  

\n

* There are also other related functions such as `aggregate()`, `map()`, `sweep()`, etc.

* We have no time to cover them all, it would take days...

* You can find info in the references and online. Here is a sampler of what can be found on the web:
http://blog.datacamp.com/r-tutorial-apply-family/
https://nsaunders.wordpress.com/2010/08/20/a-brief-introduction-to-apply-in-r/

</div>


## Let's start with `lapply()` {.build}

`lapply()` takes a function, applies it to each element in a list (or vector), and returns the results in the form of a list.

<div class="centered">

![apply explained](/media/cunnac/DONNEES/CUNNAC/Lab-Related/Communications/Teaching/R_trainning_module/slides/images/lapply.png)  
[Source: AdvancedR by Hadley Wickham](http://adv-r.had.co.nz/Functionals.html#lapply)

</div>

**Typical use cases (like loops):**  

* Apply a function on individual elements: `lapply(xs, function(x) {})`  
* Iterate over a numeric index: `lapply(seq_along(xs), function(i) {})`  
* Iterate over names as indexes: `lapply(names(xs), function(nm) {})`  



##

To illustrat a use of `lapply()`, let's create some random data and look at the number of values in each random set.
```{r}
lst <- replicate(5, rnorm(sample(1:50, 1)), simplify = FALSE)
```

With a `for` loop:
```{r}
# preallocate an empty list of the proper length to save computing time
out <- vector("list", length(lst))
# here is the loop:
for (i in seq_along(lst)) {
  out[[i]] <- length(lst[[i]]) # assign value to an element of out
}
unlist(out) # simplify to a vector rather than a list
```

With `lapply()`
```{r}
unlist(lapply(X = lst, FUN = length))
```
**The code is far more concise, isn't it?**

##

What if now, rather than determining the number of values in each random vector, we would like to compute the quantiles. How would you do that ? Does it still make sense to unlist the result?

```{r, eval= FALSE}
lapply(X = lst, FUN = quantile)
```

We would like however to overide default argument `probs` of `quantile()` to get only the min, median and max values. How can we do that?

```{r, eval= FALSE}
lapply(X = lst, FUN = quantile, probs = seq(0, 1, 0.50))
# or alternatively:
lapply(X = lst, FUN = function(vect) quantile(vect, probs = seq(0, 1, 0.50)))
```

* Additional arguments to `FUN` can be passed via `...`

* The function `FUN` can be defined elsewhere or directly in the call to apply via an anonymous function that has additional arguments.

##

We would also like to keep track of the number of values on which the quantiles are calculated. Can you append the value of `length(vect)` to the vector of quantiles?

```{r, eval= FALSE}
lapply(X = lst, FUN = function(vect) {
  quants <- quantile(vect, probs = seq(0, 1, 0.50))
  count <- c(n = length(vect))
  return(c(count, quants))
  }
)
```

Why does `count` has a fractional-part?

`sapply()` and `vapply()` are very similar to lapply() except they simplify their output to produce an atomic vector.
What happens when you use `sapply`? Do you get this:


```{r, eval= TRUE, echo= FALSE}
sapply(X = lst, FUN = function(vect) {
  quants <- quantile(vect, probs = seq(0, 1, 0.50))
  count <- c(n = length(vect))
  return(c(count, quants))
  }
)
```
What is it?
What would you do to make it easier to read? 

##

Can you also calculate the standard deviation of the values and append it to the rest of the statistics?
```{r, eval= TRUE, echo= TRUE}
mat <- sapply(X = lst, FUN = function(vect) {
  quants <- quantile(vect, probs = seq(0, 1, 0.50))
  count <- c(n = length(vect))
  sd <- c(sd = sd(vect))
  return(c(count, sd, quants))
  }
)
t(mat)
```

Does this make sense considering the way this set of random vectors was created?


## `apply()` applies a function to array margins {.build}

<div class="columns-2">
![apply explained](/media/cunnac/DONNEES/CUNNAC/Lab-Related/Communications/Teaching/R_trainning_module/slides/images/apply.png)  

\n  

[Source: Altuna Akalin](http://al2na.github.io/compgenr/intro_to_r/functions_and_control_structures_for,_ifelse_etc.html)

\n  

An exemple:
```{r}
a <- matrix(1:20, nrow = 5)
a
apply(X = a, MARGIN = 1, FUN = mean) # by rows
apply(a, 2, mean) # by columns
```

</div>

##

When MARGIN=c(1,2) the function is applied to every entry of the array `X`

So for exemple, one may want to calculate modulo ten of the values in a matrix.
How would you do it?
```{r}
m <- matrix(c(seq(from = -23, to = 25, by = 2)), nrow = 5, ncol = 5)
m
```

```{r}
apply(m, MARGIN = c(1,2), function(x) x%%10) # One option
m%%10 # is another one
```

##

But much faster:
```{r}
system.time(for (i in 1:10000) apply(m, MARGIN = c(1,2), function(x) x%%10))
system.time(for (i in 1:10000) m%%10)

```

Conclusion: think about using vectorization before using `apply`-like functions. Other notable examples include `rowMeans()`, `colSums()` and so on.  
  
But in the end, the most important is to get things done, even if it is a bit slow...



## Multiple inputs: `mapply()` and `Map()` {.build}

With `lapply()`, only one argument to the function varies; the others are fixed. This makes it poorly suited for some problems.  

Map is useful whenever you have two (or more) lists (or data frames) that you need to process in parallel.  

![apply explained](/media/cunnac/DONNEES/CUNNAC/Lab-Related/Communications/Teaching/R_trainning_module/slides/images/mapply.png)  

\n  

[Source: Altuna Akalin](http://al2na.github.io/compgenr/intro_to_r/functions_and_control_structures_for,_ifelse_etc.html)

##

* As an exemple from [Advanced R](http://adv-r.had.co.nz/Functionals.html), another way of standardising columns is to first compute the means and then divide by them. How would you do that?

```{r}
# First compute the means of the columns
mtmeans <- lapply(mtcars, mean)

# Then divide each elements of the columns by the corresponding mean of the column
mtWeightedMeans <- mapply(`/`, mtcars, mtmeans, SIMPLIFY = TRUE)
```

BTW, R has the `scale()` function to do this...


* Two nice and sometimes confusing thing about some `apply`-like functions is that:

    * they *simplify* their output.
    * when input have names, they try hard to pass them properly in their output

What happens if you set the `SIMPLIFY` and `USE.NAMES` arguments to `FALSE`?

```{r, eval = FALSE, echo = FALSE}
mtWeightedMeans <- mapply(`/`, mtcars, mtmeans, SIMPLIFY = FALSE, USE.NAMES = FALSE)
```

##

To finish, here is an example from the `mapply()` documentation that illustrates how arguments are passed to `FUN`.

```{r}
mapply(rep, 1:3, 3:1)
mapply(rep, times = 1:3, x = 3:1)
```

Do you understand why they produce different output ? Look at the help of `rep()` to refresh your memories about its arguments.



## Exercice {.build}

Write a function that calculates the cumulative sum of the elements of a numeric vector. For exeample 1, 2, 3 produces, 1, 3, 6.
First use a `for` loop:

```{r ANS07}
MyCumsumWithFor <- function(v) {
  cumSumRes <- rep(v[1], length(v)) # first create 
  for (i in 2:length(v)) {cumSumRes[i] <- cumSumRes[i-1] + v[i]}
  cumSumRes
}
v <- as.numeric(1:5)
MyCumsumWithFor(v)
```

What happens if you omit the coercion to numeric when assigning to `v` ?
Improve your function to gaurd against that.

```{r ANS08}
MyCumsumWithFor <- function(v) {
  if(!is.numeric(v)) v <- as.numeric(v)
  cumSumRes <- rep(v[1], length(v)) # first create 
  for (i in 2:length(v)) {cumSumRes[i] <- cumSumRes[i-1] + v[i]}
  cumSumRes
}
v <- 1:5
MyCumsumWithFor(v)
```

##

Can you think of a way to implement the same computation using `sapply()`?

```{r ANS09}
MyCumsumWithSapply <- function(v) {
  if(!is.numeric(v)) v <- as.numeric(v)
  cumSumRes <- rep(v[1], length(v))
  sapply(2:length(v), function(i) cumSumRes[i] <<- cumSumRes[i-1] + v[i])
  cumSumRes
}

identical(MyCumsumWithSapply(v), MyCumsumWithFor(v))
```

A bit awkward, requires the use of the "super assignment" operator.

##

Base R comes with a built-in `cumsum()`. Make sure, your function(s) and `cumsum()` produce the same output.
Which one is the fastest?

```{r ANS10}
identical(cumsum(v), MyCumsumWithFor(v))

v <- 1:1e5

system.time(MyCumsumWithFor(v))
system.time(MyCumsumWithSapply(v))
system.time(cumsum(v))
```

Conclusion:  

* `apply`-like functions are not always faster that `for` loops.  
* Whenever it exists, use a R function or you will waste both your and computing time.  



## Exercice {.build}
For a bootstraping approach, you need to extract 10 random samples of rows of the `quakes` dataset. Each random sample will have the same number of rows than the original Data Frame.
How would you do that?

```{r ANS11}
boots <- lapply(1:10, function(i) {
  rows <- sample(1:nrow(quakes), rep = TRUE)
  quakes[rows, ]
})
```

Can you generalise your code to write a function that takes any input Data Frame and where the number of random samples in the output can be specified?

```{r ANS12}
BootstrapIt <- function(df, n = 10) {
  boots <- lapply(1:n, function(i) {
    rows <- sample(1:nrow(df), rep = TRUE)
    df[rows, ]
  })
  return(boots)
}

mySample <- BootstrapIt(airquality, n = 2)
```


## Exercice {.build}

With the diamonds data frame, for each level of the cut factor, calculate the mean of each numerical column. The output should should be a rectangular object (matrix or data frame). Note that it can be done with the help of `by()` or `aggregate()`.


This is one way to do it:
```{r ANS13}
library(ggplot2)
# select only columns of numeric type
diamondsNum <- diamonds[, sapply(diamonds, is.numeric)]

meansByCutBy <- by(diamondsNum, diamonds$cut, function(x) sapply(x, mean))

# are you familiar with this:
meansByCutBy <- do.call(rbind, meansByCutBy)
meansByCutBy
```

##

Here is another one:

```{r ANS14}
meansByCutAg <-aggregate(diamondsNum, list(diamonds$cut), mean)
meansByCutAg
```

Bottom line:  

* not always trivial to decide on what function to use because it requires a very intimate knowledge of their clockwork...
* Always experiment with small data sets (toy exemple) and make sure that what you have is what you want.


## The plyr package {.build}

It is important that you get familiar with the functions of the `apply` familly, if only to understand the code of others and because `apply` flavors often percolate in packages that deal with specific object types. Also, they are shipped with base R and do not require additional package.

However, overall this set of function is relatively disparate and it is sometimes tricky to decide on what function to use (if available). This choice depends on:

- the class of your input data
- the kind of processing you want to do
- the form of output you want.

The `plyr` package, which is related to `dplyr` offers a more consistent and extensive infrastructure based on the [Split-Apply-Combine Strategy](http://seananderson.ca/2013/12/01/plyr.html).
Although `plyr` can be slow at times, it offers a very easy way to parallelise the execution of your code which may help speed up things.




