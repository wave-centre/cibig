---
title: 'IRD/CIRAD trainning to R, the statistical programming language'
author: "Sebastien Cunnac & Emmanuel Paradis"
date: "Sept. 7-11, 2015"
output:
  ioslides_presentation:
    smaller: yes
    widescreen: no
---

```{r setup, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(error = TRUE, collapse = TRUE)
```



# Character strings manipulation.

* Overview of base R capabilitites.
* If serious about character strings manipulations, take a look at the `stringr` package which offers a more coherent interface.
* Section largely based on:
    + [Gaston Sanchez  - Handling and Processing Strings in R](http://gastonsanchez.com/Handling_and_Processing_Strings_in_R.pdf)
    + [Phil Spector - Data Manipulation with R](http://www.springer.com/fr/book/9780387747309)


## Basics of character data {.build}

* A character string is placed between single or double quotes (otherwise it is something else):

```{r}
mean == "mean"
class(mean)
class("mean")
"The 'R' project for statistical computing" != 'The "R" project for statistical computing'
```

* Empty string vs Empty character vector

```{r, eval=FALSE}
a <- "" # empty string
b <- character(0) # empty character vector
```

##

* Counting the number of characters in a string

```{r,}
month.name[1:4]
length(month.name)
nchar(month.name)
```



##	Character translation and case folding: {.build}

* Character translation or substitution

```{r, collapse=TRUE}
chartr("u", "o", "union") # One characer is substituted
chartr(old = "ao", new = "A0", "This is a boring string") # Several characters can be is substituted
crazy = c("Here's to the crazy ones", "The misfits", "The rebels") # It is vectorized
chartr("aei", "#!?", crazy)
chartr("a-c", "D-F", letters[1:8]) # One can use ranges of characters
```
This is nice but regular expressions are far more powerfull...

* Case folding

```{r}
casefold("aLL ChaRacterS in LoweR caSe")
casefold("All ChaRacterS in Upper Case", upper = TRUE)
```
Note that `tolower()`and `toupper()` do as their name imply.


## Combining character strings {.build}

For combining text and variable values and have some control on the way the values are formatted.

* Vectorized concatenation of strings

```{r, collapse=TRUE}
paste("la", "maison", sep = " ") # basic concatenation, separator is a space
# Vectorized concatenation. Note that numeric vectors are converted to character.
paste("Section", 1:3, sep = "-")
paste("Section", 1:3, LETTERS[1:4], sep = "-") # Rules of recycling apply
paste("Section", 1:3, LETTERS[1:4], sep = "-", collapse = " & ") # Collapse everything to a single string
paste("Section", rep(1:3, each = 5), 1:5, sep = "-") # What is this doing!?

```

##

* To have more control on how, mostly numerical values are formated there are a number of function available. `sprintf()` is extremely convenient but a bit complex too.

```{r}
sprintf(fmt = "The number pi = %f", pi)
```
The argument fmt is a character vector mixing plain text with format strings. The **%** symbol terminated by a letter acts as a positional and convertion **flag** for insertion of the formated value of the other argument(s).

```{r}
sprintf("The number pi = %E", pi) # scientific notation
sprintf("The number pi = %.2f %s", pi, c(". Yes ?", "or not?")) # specify precision. concatenate with text
sprintf("This is %-8s justification of text", "LEFT") # Also fixing field width to 8 characters.
sprintf("This is %8s justification of text", "RIGHT")

```




## Displaying character strings {.build}


* Displaying strings in the screen, notably to generate information messages (progress of computation, weird things happening, ...) in function body.

```{r}
diceResult <- 4
cat("The dice result is: ", diceResult, "!\nTry again.", sep = "")
cat("Long strings can", "be displayed over", "several lines using",
    "the fill= argument.", fill = 40)
```

By default `cat()` prints to the stout (screen)
`cat()` returns no value (invisible NULL)


##  {.build}


* Displaying information in connection with exception handling.

Use `message()`, `warning()`, `stop()` as appropriate. These functions are part of the R condition system (`?conditions`), a mechanism for signaling and handling anomalous or exceptional events occuring during the execution of your code.

```{r}
howRU <- function(x) {
  message("Will first check the type of the argument.")
  if (!is.logical(x)) {stop("Argument must be either 'TRUE' or 'FALSE'.\n")} # asserting argument type
  if (x) cat("I am fine, thank you!\n") else warning("I don't feel so good.\n") # issue a warning if feel sick
  cat("Good bye")
}
howRU("bof") # Trows an error: execution alted
howRU(TRUE) # prints something to stdout
howRU(FALSE) # warns you that something is unusual
```

## Text Extraction with `substring()` {.build}

```{r}
# extract based on a range of positions
substring(text = "abcdef", first = 2, last = 4)

# vectorized extraction
substring("abcdef", first = 1:4, last = 4:5) # the 'x' and 'last' vectors are recycled

# replacing portions of strings with the assignment operator
x = c("may", "the", "force", "be", "with", "you")
substring(x, 2, 2) <- "#"
x

# everything is a vector...
s <- c("more", "emotions", "are", "better", "than", "less")
substring(s, 1:3, 2:4) <- c(" ", "zzz")
s

```
Can you insert a string longer than the range provided in the `first` and `last` arguments?



##  A touch of regular expressions {.build}
* Regular expressions is a powerfull and flexible tool for finding and replacing text using patterns/motifs.

```{r}
# What strings are email adresses?
s <- c("object@attribute", "Rstudio", maintainer("base"))
# The litteral approach
grep(pattern = "@", x = s, value = TRUE)
# Accurate with a more specifc pattern
myPat <- "([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})"
grep(pattern = myPat, x = s, value = TRUE)
```

* Implemented in most languages.  
* A pretty rich syntax! No time to cover it here.
* A excellent ressource to learn: http://www.regular-expressions.info/index.html

##  A touch of regular expressions {.build}
* Base R has a variety of functions that use regular expressions for different but related purposes:  
  
  
![](/media/cunnac/DONNEES/CUNNAC/Lab-Related/Communications/Teaching/R_trainning_module/slides/images/RegularExpressionFunctionsTable.jpg)  
  
  
* Note that for most of these functions you can specify, via its arguments, whether to interpret the provided pattern literally or to use one the two available regexp engines : Perl or POSIX 1003.2 (unix).
There are differences in the fonctionalities depending on the engine used. So be aware of what you use.  

##  A touch of regular expressions {.build}




* Finding vector elements that have the pattern:

```{r}
s <- c("tobacco pipe (hazardous!)", "pile of junk", "directory of files")
grepl("pi", s)
```

* Double escaping of metacharacters (special characters) and search for their literal meaning.

```{r}
grep("(", s, value = TRUE) # parentheses create capturing groups
grep("\\(", s, value = TRUE) # escape special meanning with DOUBLE backslash
```

##

* Extracting only the matched substrings from match data obtained by `regexpr()`, `gregexpr()` or `regexec()`.

```{r}
m <- regexpr(pattern = "pi[pl]e", text = s) # brakets define a character set
m
regmatches(x = s, m = m, invert = FALSE)
```

Note that similar to `sub` functions below, `regmatches()` can do substitution tasks via the assignemnt operator.

* Replacing the matched pattern with a new value

```{r}
sub(pattern = "pi[pl]e", replacement = "cigarette", x = s)
gsub("\\d", "_", "1789, the revolution") # global substitution of digits
```

##

* Split strings based on a separator defined by a regexp

```{r}
# Often used to get the words of a sentence
s <- c("Killian! I'll be back!",
"You cannot teach a man anything; you can only help him find it within himself â€“ Galileo")
words <- strsplit(x = s, split = " ")
words # the returned object is a list of vectors

# It can be flattened
unlist(words)[1:10]

# It can be used in a `apply` construct
sapply(words, length) # number of words in the sentense

```



`strsplit()` with sep = "" is used to break a string into a vector of single characters.
Try it!



## Exercice {.build}
You have 12 samples and want to create dummy labels like "S_1".
How would you do that with `paste()`?
Assign your resulting character vector to the name "lab1"

Can you do it with `sprintf()` so that the numeric field is of width 2 with padding with zeros like "S_03"? Tip: look for "0" in the `sprintf()` help page.
Assign your resulting character vector to the name "lab2"

Sort lab1 and lab2. What format is the most convenient?

```{r ANS01, collapse=TRUE}
cat(lab1 <- paste("S", 1:12, sep = "_"))
cat(lab2 <- sprintf("S_%02i",  1:12))
sort(lab1)
sort(lab2)
```

## Exercice {.build}
How would you find the position(s) at which the letter *s* occurs in *saucisson sec*? As usual with R, there are several ways to do that...

```{r ANS02}
s <- "saucisson sec"
## 1 ## The brutal way {.build}
# Break down string to a vector of single characters
vectOfSingleChar <- substring(s, 1:nchar(s), 1:nchar(s)) # First solution
vectOfSingleChar <- unlist(strsplit(s, split = "")) # Second, more 'elegant' solution

# Find indexes of vector elements corresponding to "s"
which(vectOfSingleChar == "s")

## 2 ## Using regular expressions {.build}
gregexpr("s", s)
```

Bottom line: learn regular expressions...
Also, when you want to accomplish a task, think twice about the approach, some are easier to implement, more elegant and more efficient than others.


## Exercice {.build}
How would you capitalize the first letter of each word of a sentence?
Create a function for that.

```{r ANS03}
simpleCap <- function(s) {
spls <- strsplit(s, " ")[[1]]

paste(toupper(substring(spls, 1, 1)),
      substring(spls, 2),
      sep = "", collapse = " ")
}
simpleCap("This is a sentence.")
```

## Exercice: {.build}
You are running a full factorial experiment on subjects treated with a drug. Here are the factors involved and their levels:

```{r ANS04}
dose <- seq(60, 80, 10)
exposureTime <- c(100, 200)
sex <- c("Male","Female")
```


You want to create treatment labels corresponding to combinations of the levels of the factors. How would you do that?
Tip: use `expand.grid()`

```{r ANS05}
mdf <- expand.grid(dose, exposureTime, sex)
apply(X = mdf, MARGIN = 1, FUN = paste, collapse = "-")
```

## Exercice {.build}

Read the file *englishWords.txt* in R. It contains a compedium of the words in the English language.

What is the longest word?
What is the median word length in English?
How many words end with "tion"?



```{r ANS06}
f <- "/media/cunnac/DONNEES/CUNNAC/Lab-Related/Communications/Teaching/R_trainning_module/filesToBringToTrainning/englishWords.txt"
words <- readLines(f)
wl <- nchar(words)
max(wl)
words[wl == max(wl)] # longest word
mwl <- median(wl) # median of word length
mwl

tionWords <- grep("tion$", words, value = TRUE) # words ending with "tion"
tionWords[1:10]
length(tionWords)
```

##


Generate 10E6 random five letter words. Tip use the function `replicate()`.
Do you have any of them that turns out to be genuine English? What are they?
How would you run that a decent number of times to get a chance to have a match?


```{r ANS07, eval= FALSE}
# First have a sense of the distribution of letters in "real" words:
letterDistris <- lapply(strsplit(words, ""), FUN = function(x) {
  x <- factor(x, levels = letters)
  as.matrix(table(x))
  }
)

letterFreq <- prop.table(table(factor(unlist(strsplit(paste(words, collapse = ""), "")), levels = letters)))

numbOfSampling <- 1E6

replicate(3, 
             {
             randWords <- replicate(numbOfSampling,
                                    paste(sample(letters, mwl, replace = TRUE, prob = letterFreq), collapse = "")
                                    )
             intersect(randWords, words)
             }
)
```
