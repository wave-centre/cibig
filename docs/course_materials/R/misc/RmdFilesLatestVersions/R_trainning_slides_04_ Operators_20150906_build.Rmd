---
title: 'IRD/CIRAD trainning to R, the statistical programming language'
author: "Sebastien Cunnac & Emmanuel Paradis"
date: "Sept. 7-11, 2015"
output:
  ioslides_presentation:
    smaller: yes
    widescreen: no
---

```{r setup, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(error = TRUE, collapse = TRUE)
```


# Mathematical and statistical computations on numeric and logical vectors: basic functions and operators


## An outlook on built-in basic mathematical and statistical functions {.build}

* Arithmetic Operators : just like on your pocket calculator:

```{r}
x <- c(2, -1, 0) ; y <- 1:3
+y
-x # change the sign
x + y # addition
x - y # substraction
x * y # multiplication
x / y # division
x ^ y # power
x %% y # modulo
x %/% y # integer division

```

##
If you want a larger sample:
```{r, eval= FALSE}
?Arithmetic 
?sqrt
?complex
?log
?Trig
?round
?Special # factorial, number of combinations of k elements in n...
```

R is stuffed with lots of useful functions to calculate esoteric things.  
Take a look at the cheatsheet and use Google if you have specific needs.

##

* Summary functions: work on vectors and return single (scalar) value in a vector.

```{r}
x <- 10:5
mean(x)
median(x)
sd(x) # standard deviation
max(x)
min(x) # see also range() and parallelized pmin et pmax
sum(x)
prod(x)
length(x) # more a 'language' function but is a summary as well
```

Many of the functions returning a summary of a vector have the default argument `na.rm = FALSE` to decide on what to do in case the vector contains `NA`s.

##

* Window functions
    - Unlike summary/aggregation function (*e.g.* `sum()`), a *window function* takes `n` inputs and returns `n` values.
    - Unlike simple *vectorised functions* like `cos()`, the computation of the returned value `i` depend on more elements of the input vector than the single `i`th one.
    - Offset functions `dplyr::lead()` and `dplyr::lag()` return values 'shifted' by one position relative to the index of the input vector.
```{r}
x <- 1:5
dplyr::lead (x)
dplyr ::lag (x)
```
*
    - Cumulative aggregates
```{r}
cumsum(x)
cummin(c(2:4, 0, 3:6))
```

*
    - Ranking functions: return the ranks of the values in `x`, to be basics discussed later.




## Exercice {.build}

* Calculate 5 to the power 3.

```{r ANS01}
5^3
```

* What will be the absolute values of applying this function `x – 0.5 *pi` to `x` when `x` is 0,1,2,3,4 and 1 million?

```{r ANS02}
x <- c(1:4, 1e6)
abs(x-0.5*pi)
```

* Let's take the sequence of numbers:

```{r}
x <- c(2, 4, 6, 8)
```

Using `dplyr::lag()`, calculate the difference between each element of x and the element immediately before. Is this an arithmetic sequence?

```{r ANS03}
x - dplyr::lag(x)
```

## Relational Operators {.build}

* Return **logical** vectors corresponding to the result of the test for numerical (character) equalities, inequalities, ...

```
x < y: is x less than y?  
x > y: is x greater than y?  
x <= y: is x less than or equal to y?  
x >= y: is x greater than or equal to y?  
x == y: is x equal to y?  
x != y: is x not equal to y?
```
* These binary operators are vectorized and apply vector recylcing rules

```{r}
1:2 == (1+1)*(1:2)/2 # vectorized
1:2 == 1:4 # recycling if not of same length
```

* Sameness (object identity) *vs.* content equality
```{r}
2==2L # values are coerced to a common type and tested
identical(2, 2L) # this tests object identity.
NA == 2L # makes sense...
```

##

* More about equality testing : precision  
  `all.equal(....)` tests equality and tolerates small differences.

* Handy functions in connection to relational operators and logical vectors.
    - `which()` gives the TRUE indices of a logical object, allowing for array indices.

```{r}
which(c(FALSE, TRUE, FALSE, TRUE))
```
*    - `match()` returns a vector of the positions of (first) matches of its first argument in its second.

```{r}
match(x =c("c", "f"), table = letters, nomatch = 0) # index of first matches of x in table
match(x = 2, table = c(1,2,3,1,2,3))
match(x = c(1,2,3,1,2,3), table = 2, nomatch = 0)
match(x = c(1,2,3,1,2,3), table = c(1,2), nomatch = 0)
```

##

*    - The `%in%` operator determines whether each value in the left operand can be matched with one of the values in the right operand and returns a logical vector. It is very handy for subsetting (will see a bit later).

```{r}
# all return the same thing:
match(x = c(1,2,3,1,2,3), table = c(1,2), nomatch = 0) > 0
c(1,2,3,1,2,3) %in% c(1,2) 
is.element(c(1,2,3,1,2,3), c(1,2))
```

*    - `all()`, `any()`, see exercice.

## Exercice {.build}
* Run this and try to understand the results:

```{r, eval=FALSE}
0 == "0"
0 == FALSE
```

* What should then be the result of `"0" == FALSE`

```{r ANS04}
"0" == FALSE
```

* What about `"2" == 2`?

```{r ANS04.1}
"2" == 2
```



## Exercice {.build}

Let's take the vectors `v` and `w` defined below:

```{r}
v <- c(3,5)
w <- c(1,5,3,8)
```


I ran `v >= w` and got the follwing result: `[1]  TRUE FALSE  TRUE TRUE`.  
Is there something wrong with my R engine? Why?

```{r, ANS05}
v >= w
```

## Exercice {.build}

Using the `sum()` function on logical vectors, how would you emulate the `all()` and `any()` functions.  
Test your code with `x` and `y` below.

```{r}
x <- c(TRUE, TRUE, TRUE)
y <- c(FALSE, TRUE, FALSE, FALSE)
```


```{r ANS06}
# all()
sum(x) == length(x)
identical(sum(x) == length(x), all(x))
sum(y) == length(y)
```

```{r ANS07}
# any()
sum(y) != 0
any(y)
```

##

```{r ANS08}
# but, if you try that with
w <- c(FALSE, TRUE, NA, FALSE)
sum(w) != 0
any(w)

# and
sum(w) == length(w)
all(w)

# -> Need to be aware of missing values!!!
# -> A little code testing never hurts...
```


## Operator precedence {.build}

<div class="columns-2">

* Operator precedence rules define the order in which a series of operators have to be computed in an expression.
* For example, in the mathematical expression below, `*` has precedence relative to `+`. The parenthesis force its content to be calculated first:  
    - `2+3×4=14`  
    - `(2+3)×4=20`

* Here is a table of R's unary and binary operators listed in precedence groups, in decrasing priority.
Type `?Syntax` for a more readable version of this table from the documentation.

![](/media/cunnac/DONNEES/CUNNAC/Lab-Related/Communications/Teaching/R_trainning_module/slides/images/operatorPrecedence.png)

</div>


**Do not hesitate to use the parenthesis to more clearly delineate in what order things are to happen.**  
It helps you and people that read your code understand the underlying order.


## Exercice: {.build}

Try to guess the result of the evaluation of these expressions:
Advice: in nested operations like these, first resolve inner operations and then proceed outwardly.

```{r, eval=FALSE}
2*1 + 2 >= 5

2 * (1+2) >= 5

!c("C", "logic") %in% c("A", "C", "D", "C")
c("C", "logic") %in% c("A", "C", "D", "C")

2*1+2 >= 5 & c("C", "logic") %in% c("A", "C", "D", "C")

!TRUE | 2*1+2 >= 5 & c("C", "logic") %in% c("A", "C", "D", "C")
FALSE | 2*(1+2) >= 5 & c("C", "logic") %in% c("A", "C", "D", "C")

FALSE || 2*(1+2) >= 5 & c("C", "logic") %in% c("A", "C", "D", "C")
(FALSE || 2*1+2 >= 5) & c("C", "logic") %in% c("A", "C", "D", "C")
```




