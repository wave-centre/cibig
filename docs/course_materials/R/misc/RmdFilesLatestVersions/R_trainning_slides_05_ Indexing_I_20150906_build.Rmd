---
title: 'IRD/CIRAD trainning to R, the statistical programming language'
author: "Sebastien Cunnac & Emmanuel Paradis"
date: "Sept. 7-11, 2015"
output:
  ioslides_presentation:
    smaller: yes
    widescreen: no
---

```{r setup, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(error = TRUE, collapse = TRUE)
```


# Data manipulation I: play with the vector and make it your toy.

## Indexing and subesetting for vectors {.build}

To subset a vector `x`, use an indexing vector `idx` (that can be a scalar) that will be placed within the`[]` operator and refers to the elements of `x` that should be returned: `x[idx]`

`idx` can be one of three types:

* integer
* logical
* character

To illustrate these alternatives, let's first create an integer vector: 
```{r}
x <- 101:105 # the ':' is a shorthand for the function seq() that we will see later.
# Name the elements
names(x) <- c("A", "B", "C", "D", "E")
# OR
x <- setNames(101:105, c("A", "B", "C", "D", "E"))
x
```

## Indexing with integer values {.build}


* **Positive integers select elements at specific positions, the same positions can be repeated.**  
  
![](/media/cunnac/DONNEES/CUNNAC/Lab-Related/Communications/Teaching/R_trainning_module/slides/images/vectorNumericIndexing.png)  [Source : Hands-On Programming with R](http://shop.oreilly.com/product/0636920028574.do)

```{r, eval= FALSE}
x[c(2, 3, 3)] # several elements, the same position(s) can occur several times
x[3:5] # generate a sequence of numerics and subset with it.
x[c(1, 105)] # out of bound index values generate NAs
```

* Negative integers exclude the corresponding elements

```{r, eval=FALSE}
x[-2] # Everything but the second element.
```
**NB**: One cannot mix positive en negative indexes

## Exercice {.build}

* What happens if you subset with zero?  
* Extract all the elements of `x` but the first.  
* Extract all elements but the last two ones with the `length()` function 


```{r ANS01, eval= TRUE}
x[0]
x[-1]
x[-((length(x)-1):length(x))]
```


## Logical Indexing {.build}
**Logical vectors keep elements at positions corresponding to TRUE, recycled if necessary without warning.**

![](/media/cunnac/DONNEES/CUNNAC/Lab-Related/Communications/Teaching/R_trainning_module/slides/images/vectorLogicalIndexing.png) [Source : Hands-On Programming with R](http://shop.oreilly.com/product/0636920028574.do)

```{r, eval=TRUE}
x[c(TRUE, FALSE, FALSE, TRUE, TRUE)]

x[c(T, F)] # if logical vector is too short, it is recycled.

v <- x[c(T, T, T, T, T, T, T)]
v # if logical vector is too long, NAs are returned
```

##

Logical indexing is often employed to select specific subsets meeting some condition of interest:
```{r}
idx <- x > 102 & x <= 104 # logical vector
idx

x[idx]
```

## Exercice {.build}

* Select all values in `x` that are ±1 standard deviations away from the mean.

```{r ANS02}
x[ abs(x - mean(x)) > sd(x) ]
```

* Select all elements in `v` that are not `NA`.

```{r ANS03}
v[ !is.na(v) ]
```

* When you get the chance, type `apropos("^is.")` and `demo("is.things")` to have a sense of the tons of functions that allows to test the nature of R objects.

## Name indexing {.build}
**Character vectors select elements with matching names.**
Note that partial matching is not allowed.

```{r}
x[c("A", "A", "D")]
```

Can you 'emulate' name indexing by calling `match()` on the vector of names?
```{r}
idx <- match(c("A", "A", "D"), names(x))
idx
x[idx]
```

##

Name indexing is also very handy to create look-up tables (in the form oldValue = "new value") to recode a variable :
```{r}
v <- c("three", "four", "one", "two", "three", "one", "four") # Vector to be recoded.
lookUp <- c(one = "un", two = "deux", three = "trois", four = "quatre") # look-up table

v

unname(lookUp[v]) # recoding and getting ride of names
```

Can you think of another way to do that with utilities for factors?
```{r}
w <- as.factor(v)
levels(w)

levels(w) <- c("quatre", "un", "trois", "deux")

as.character(w)
```


## Modifying vectors (and other objects) in place via subsetting and the assignment operator {.build}
**All subsetting operators can be combined with assignment to modify selected values of the input vector. The rest of the vector is unaffected.**

* Basic examples:

```{r}
oldX <- x
x[1] <- 1

x < 103
x[ x < 103 ] <- 0

x
```

##

* Be aware of what happens when vectors on either side of the assignment have different lenghts.

```{r}
x[1:4] <- 0:1 # The right hand side vector is recycled once to match the length of the 'subseted' vector
x

x[1:2] <- 10:14 # WARNING + the subset of x is modified with the first elements of the replacement vector
x
```

* Indices and Nas

```{r}
x[c(1, NA)] <- c(1, 2) # You CAN'T combine integer indices with NA
x

x[c(T, F, NA)] <- 1000 # in logical indices NA are treated as false
x
```

##

* To delete elements, just subset what you want and re-assign the name of your object to it.

* Assignment with a logical vector is widely used as a substitute to `for`-`if` or `ifelse()` constructs (described later).

```{r}
x <- 1:4
isOddX <- as.logical(x %% 2) # modulo 2 is not 0

x[which(isOddX)] # even numbers

x[isOddX] <- x[isOddX] + 1 # do something about odd numbers
x
```
Will be illustrated in some Exercices further down the road!


## Exercice {.build}

The `rev()` function returns a reversed version of its argument.

```{r}
rev(LETTERS)
```

Can you think of a way to reverse the `LETTERS` vector without this function?

```{r ANS04}
LETTERS
LETTERS[length(LETTERS):1]
```


## Exercice {.build}

How would you append value(s) in `x` at the right end of vector `v`? There is a fastidious way and a simple one to do that.

```{r}
x <- 5:8
v <- 1:4
```

* The easy way:

```{r ANS06}
v <- c(v,x)
v
```

* The painstaking one: 

```{r ANS07}
v <- 1:4
v[length(v) + 1] <- x # What happen if you add more than one to the index?
v
```

##

* With no warnings:

```{r ANS08}
v <- 1:4
v[(length(v)+1):(length(v)+length(x))] <- x # No warning
v
```

* What happen if you remove the parenthesis around the '+' operations?  
  This is relevant to operator precedence. See: `?Syntax`

How would you **insert** the values of `x` at a specific location within `v`, rather than the end?

* Use `append()`

```{r ANS09}
v <- 1:4
v <- append(v, values = x, after = 2)
v
```

* If you are curious, it can be interesting to look at what `append()` is actually doing with the F2 key.


## Exercice {.build}

How can you extract consonants with the vector of vowels? Tip: the built-in constant `letters` contains the 26 lower-case letters of the Roman alphabet.

```{r ANS10}
idx <- letters %in% c("a", "e", "I", "o", "u", "y")
letters[!idx]
```


## Generating regular sequences {.build}
It is often necessary to generate regular sequences or patterns of values, for exemple when you want to assign replicated levels of factors to experimental units.

In R there are at least two base functions to do this kind of work:

* the `seq(from, to, by, length.out, along.with, ...)` which is a generalization of the `from:to` operator."  
  As you will see in its doc, this function is pretty versatile.
  Typical usages include:

```{r}
seq(from = 1, to = 6)
seq(from = 1, to = 6, by = 2)
seq(from = 1, by = 2, length.out = 3)
seq(along.with = v)
seq(5)
seq(length.out = 4)
```

##

* The `rep(x, times, each, length.out)`  
  Again this function is pretty versatile and all kind of patterns can be generated.

```{r}
s <- c("a", "b", "c")
rep(s, times = 2)
rep(s, each = 2)
rep(s, times = 1:length(s))
rep(s, each = 3, times = 2)
rep(s, each = 2, length.out = 4)
rep(s, each = 2, length.out = 10)
```

* Along the same line `gl()` generates factors by specifying the pattern of their levels.

## Exercice {.build}
[Source](http://pbil.univ-lyon1.fr/R/pdf/tdr13.pdf)

Write the expressions that generated the following patterns:
```
1 2 3 1 2 3 1 2 3
4 3 2 1 4 3 2 1 4 3 2 1
1 1 1 2 2 2 3 3 3 4 4 4
"un"   "un"   "un"   "deux" "deux" "deux" "deux" "deux" "deux"
1.0 1.0 1.5 1.5 2.0 2.0 2.5 2.5 1.0 1.0 1.5 1.5 2.0 2.0 2.5 2.5
```

```{r ANS11}
rep(1:3, times = 3)
rep(4:1, times = 3)
rep(1:3, each = 3)
rep(c("un", "deux"), times = c(3, 6))
rep(seq(1, 2.5, by = 0.5), each = 2, times = 2)
```


## Exercice {.build}

Let's take:
```{r}
x <- seq(1, 20, by = 2)
x
```

Extract every third elements of `x`. You will do that both using a logical and an integer index.

Integer indexing:

```{r ANS12}
x[seq(3, length(x), by = 3)]
```

Logical indexing:

```{r ANS13}
x[rep(c(FALSE, FALSE, TRUE), times = length(x)/3)]
```


## Creating vectors of random numbers {.build}

<div class="columns-2">

![](/media/cunnac/DONNEES/CUNNAC/Lab-Related/Communications/Teaching/R_trainning_module/slides/images/randomDistributions.png)
[Source: R pour les débutants](https://cran.r-project.org/doc/contrib/Paradis-rdebuts_fr.pdf)  

* R boost one of the best random generators and offers functions to easily generate random numbers from various distributions.

* Density (function prefix `d`), cumulative distribution function (`p`), quantile function (`p`) and random variate generation (`r`) for many standard probability distributions are available in the stats package. Look at `?distribution`.

</div>

* If you want to reproduce work later, call `set.seed()` that will set the seed of R‘s random number generator, which is useful for creating simulations or random objects that can be reproduced.

##

An exemple, generating random samples from a normal distribution:

```{r}
  set.seed(124)
rnorm(n = 5 , mean = 10, sd = 3)

set.seed(421)
rnorm(n = 5 , mean = 10, sd = 3)

set.seed(124)
rnorm(n = 5 , mean = 10, sd = 3)
```

Or from a uniform distribution:
```{r}
runif(n = 5, min = 0, max = 10)
```


## Randomly sampling objects from a vector. {.build}
The `sample()` function is used to draw a random sample from a given population. It can be used to sample *with* or *without* replacement by using the `replace` argument (**the default is F**).

A few examples:
```{r}
sample(x = month.abb, size = 5)
sample(x = month.abb, size = 13)
sample(x = month.abb, size = 13, replace = TRUE )
sample(x = c(0,1), size = 20, replace = TRUE, prob = c(0.1, 0.9))
```


## Sorting vectors {.build}

* To sort vectors or factors, the most intuitive function is `sort()`.  
  It **returns the elements of the input vector** in *increasing* or *descending* order depending on arguments.
```{r}
x <- c(13,5,12,5)
sort(x, decreasing = TRUE)
```

* `order()` is actually more flexible in the sense that it allows to sort objects based on several sorting keys. We will use it for data frames later.  

In contrast to `sort()`, it does not return the input object but **a vector of integer representing the indices of the elements of the input**. These indices are permuted to reflect the increasing or decreasing order of the input object.  

Let's see an example...  

##

```{r}
someMonths <- c(sample(x = month.abb, size = 13, replace = TRUE ), NA)
someMonths
idx <- order(someMonths, na.last = FALSE, decreasing = FALSE) # Note the optional arguments!!
idx
```

* This index can be used to actually *re-order* the original object:
```{r}
someMonths[idx]
```

* The last function of interest is `rank()` that returns the sample ranks of the values in a vector:

```{r}
x <- c(3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5)
names(x) <- letters[1:11]
rank(x, ties.method = "first")
rank(x, ties.method = "average")

### ALWAYS BE AWARE OF HOW TIES ARE HANDELED!! ###
```


## Comparing vectors: set operations {.build}

R includes some handy set operations, including these:


Function        |  Description
----------------|--------------------------------------
`union(x,y)`      |  Union of the sets `x` and `y`
`intersect(x,y)`  |  Intersection of the sets `x` and `y`
`setdiff(x,y)`    |  Set difference between `x` and `y`, consisting of all elements of `x` that are not in `y`
`setequal(x,y)`   |  Test for equality between `x` and `y`
`is.element(el, set) ; c %in% y` |  Membership, testing whether `c` is an element of the set `y`
`choose(n,k)`  |  Number of possible subsets of size `k` chosen from a set of size `n`

\n

Note that `x` and `y` are vectors of the same mode preferentially **with no duplicated values**. Replicate will not be returned.


##

Here are some simple examples of using these functions:

```{r}
x <- 1:10
y <- c(3:6, 12, 12, 15, 18)
union(x, y)
intersect(x, y)
setdiff(x, y)
setdiff(y, x)
is.element(2, x)
is.element(y, x)

let <- letters[1:2]
union(y, let) # Note the implicit type coercion
```


## Exercice {.build}

* Generate a numeric vector of 400 random values sampled from a uniform distribution with a maximum of 100.  
* Display a summary of this vector.  
* How many values are greater than the first quartile but less than the median? Tip: use `quantile()?

```{r ANS14}
x <- runif(n = 400, max = 100)
summary(x)

firstQuart <- quantile(x)[2] # 1/4 of the values in x are <= to this
med <- median(x) # or quantile(x)[3]

idx <- x > firstQuart & x < med # combine logical vectors to from an index

length(x[idx]) # subset x with index and return the lenght of this subset.
# OR
sum(idx) # logical are converted to integer
```

Does it make sense…?


## Exercice {.build}

* Create a character vector populated with 10 values of the name of the months randomly sampled (with replacement) from the built-in variable `month.name`.

* Replace values in this vector with the numbers of the corresponding months (*e.g.* March with 3).

```{r ANS15}
ranMonths <- sample(month.name, 10, replace = TRUE)
ranMonths
months <- 1:12
names(months) <- month.name

unname(months[ranMonths])
```


## Exercice {.build}
[Source: R for Biologists - Prof. Daniel Wegmann](https://moodle2.unifr.ch/course/view.php?id=9409)

Create a numerical vector `f` containing the elements 1, −1, 2, −2, . . . , 100, −100

```{r ANS16}
f <- c(1,-1) * rep(1:100, each = 2) # vectorized multiplication with recycling...
```

Create a vector of 100 elements that contains the numbers 1,2 and 3 in random order, but with twice as many 1s than 2s or 3s.

```{r ANS17}
sample(1:3, 100, prob = c(2,1,1), replace = T)
```



## Exercice {.build}
[Source: R for Biologists - Prof. Daniel Wegmann](https://moodle2.unifr.ch/course/view.php?id=9409)

1. Create two vectors `x` and `y` containing 1000 random numbers normally distributed with sd=1 and mean=0 and mean=1, respectively.
2. Calculate the number of pairs (`x[i]`, `y[i]`) where `y[i]>x[i]`.
3. Calculate the number of values in `y` that are larger than the largest value in `x`.
4. Calculate the number of values in `x` that are larger than the 200 th smallest value in `y` and less than two standard deviations away from the mean of `x`.
5. Create a vector `z` with all 999 differences between the neighboring elements of `x` such that z[1]=x[2]-x[1], z[2]=x[3]-x[2], . . ..

##

```{r ANS18}
#1 Create two vectors x and y...
x <- rnorm(1000, mean = 0)
y <- rnorm(1000, mean = 1)

#2 Calculate the number of pairs (x[i], y[i]) where y[i]>x[i].
sum(y > x)

#3 Calculate the number of values in y that are larger than the largest value in x.
sum(y > max(x))

#4 Calculate the number of values in x that are larger than the 200th smallest value in y and less than two standard deviations away from the mean of x.
sum(x < sort(y)[200] & abs(x - mean(x)) / sd(x) < 2)

#5 Create a vector `z` with all 999 differences between the neighboring elements of `x`...
z <- x[2:length(x)] - x[1:(length(x) - 1)]
```
